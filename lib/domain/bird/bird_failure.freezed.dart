// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'bird_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$BirdFailureTearOff {
  const _$BirdFailureTearOff();

  NameTooLong nameTooLong() {
    return const NameTooLong();
  }

  NotNumber notNumber() {
    return const NotNumber();
  }

  WrongId wrongId() {
    return const WrongId();
  }

  UnexpectedFailure unexpectedFailure(String? message) {
    return UnexpectedFailure(
      message,
    );
  }
}

/// @nodoc
const $BirdFailure = _$BirdFailureTearOff();

/// @nodoc
mixin _$BirdFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameTooLong,
    required TResult Function() notNumber,
    required TResult Function() wrongId,
    required TResult Function(String? message) unexpectedFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameTooLong,
    TResult Function()? notNumber,
    TResult Function()? wrongId,
    TResult Function(String? message)? unexpectedFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NameTooLong value) nameTooLong,
    required TResult Function(NotNumber value) notNumber,
    required TResult Function(WrongId value) wrongId,
    required TResult Function(UnexpectedFailure value) unexpectedFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NameTooLong value)? nameTooLong,
    TResult Function(NotNumber value)? notNumber,
    TResult Function(WrongId value)? wrongId,
    TResult Function(UnexpectedFailure value)? unexpectedFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BirdFailureCopyWith<$Res> {
  factory $BirdFailureCopyWith(
          BirdFailure value, $Res Function(BirdFailure) then) =
      _$BirdFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$BirdFailureCopyWithImpl<$Res> implements $BirdFailureCopyWith<$Res> {
  _$BirdFailureCopyWithImpl(this._value, this._then);

  final BirdFailure _value;
  // ignore: unused_field
  final $Res Function(BirdFailure) _then;
}

/// @nodoc
abstract class $NameTooLongCopyWith<$Res> {
  factory $NameTooLongCopyWith(
          NameTooLong value, $Res Function(NameTooLong) then) =
      _$NameTooLongCopyWithImpl<$Res>;
}

/// @nodoc
class _$NameTooLongCopyWithImpl<$Res> extends _$BirdFailureCopyWithImpl<$Res>
    implements $NameTooLongCopyWith<$Res> {
  _$NameTooLongCopyWithImpl(
      NameTooLong _value, $Res Function(NameTooLong) _then)
      : super(_value, (v) => _then(v as NameTooLong));

  @override
  NameTooLong get _value => super._value as NameTooLong;
}

/// @nodoc

class _$NameTooLong with DiagnosticableTreeMixin implements NameTooLong {
  const _$NameTooLong();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BirdFailure.nameTooLong()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'BirdFailure.nameTooLong'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NameTooLong);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameTooLong,
    required TResult Function() notNumber,
    required TResult Function() wrongId,
    required TResult Function(String? message) unexpectedFailure,
  }) {
    return nameTooLong();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameTooLong,
    TResult Function()? notNumber,
    TResult Function()? wrongId,
    TResult Function(String? message)? unexpectedFailure,
    required TResult orElse(),
  }) {
    if (nameTooLong != null) {
      return nameTooLong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NameTooLong value) nameTooLong,
    required TResult Function(NotNumber value) notNumber,
    required TResult Function(WrongId value) wrongId,
    required TResult Function(UnexpectedFailure value) unexpectedFailure,
  }) {
    return nameTooLong(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NameTooLong value)? nameTooLong,
    TResult Function(NotNumber value)? notNumber,
    TResult Function(WrongId value)? wrongId,
    TResult Function(UnexpectedFailure value)? unexpectedFailure,
    required TResult orElse(),
  }) {
    if (nameTooLong != null) {
      return nameTooLong(this);
    }
    return orElse();
  }
}

abstract class NameTooLong implements BirdFailure {
  const factory NameTooLong() = _$NameTooLong;
}

/// @nodoc
abstract class $NotNumberCopyWith<$Res> {
  factory $NotNumberCopyWith(NotNumber value, $Res Function(NotNumber) then) =
      _$NotNumberCopyWithImpl<$Res>;
}

/// @nodoc
class _$NotNumberCopyWithImpl<$Res> extends _$BirdFailureCopyWithImpl<$Res>
    implements $NotNumberCopyWith<$Res> {
  _$NotNumberCopyWithImpl(NotNumber _value, $Res Function(NotNumber) _then)
      : super(_value, (v) => _then(v as NotNumber));

  @override
  NotNumber get _value => super._value as NotNumber;
}

/// @nodoc

class _$NotNumber with DiagnosticableTreeMixin implements NotNumber {
  const _$NotNumber();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BirdFailure.notNumber()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'BirdFailure.notNumber'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NotNumber);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameTooLong,
    required TResult Function() notNumber,
    required TResult Function() wrongId,
    required TResult Function(String? message) unexpectedFailure,
  }) {
    return notNumber();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameTooLong,
    TResult Function()? notNumber,
    TResult Function()? wrongId,
    TResult Function(String? message)? unexpectedFailure,
    required TResult orElse(),
  }) {
    if (notNumber != null) {
      return notNumber();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NameTooLong value) nameTooLong,
    required TResult Function(NotNumber value) notNumber,
    required TResult Function(WrongId value) wrongId,
    required TResult Function(UnexpectedFailure value) unexpectedFailure,
  }) {
    return notNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NameTooLong value)? nameTooLong,
    TResult Function(NotNumber value)? notNumber,
    TResult Function(WrongId value)? wrongId,
    TResult Function(UnexpectedFailure value)? unexpectedFailure,
    required TResult orElse(),
  }) {
    if (notNumber != null) {
      return notNumber(this);
    }
    return orElse();
  }
}

abstract class NotNumber implements BirdFailure {
  const factory NotNumber() = _$NotNumber;
}

/// @nodoc
abstract class $WrongIdCopyWith<$Res> {
  factory $WrongIdCopyWith(WrongId value, $Res Function(WrongId) then) =
      _$WrongIdCopyWithImpl<$Res>;
}

/// @nodoc
class _$WrongIdCopyWithImpl<$Res> extends _$BirdFailureCopyWithImpl<$Res>
    implements $WrongIdCopyWith<$Res> {
  _$WrongIdCopyWithImpl(WrongId _value, $Res Function(WrongId) _then)
      : super(_value, (v) => _then(v as WrongId));

  @override
  WrongId get _value => super._value as WrongId;
}

/// @nodoc

class _$WrongId with DiagnosticableTreeMixin implements WrongId {
  const _$WrongId();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BirdFailure.wrongId()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'BirdFailure.wrongId'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WrongId);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameTooLong,
    required TResult Function() notNumber,
    required TResult Function() wrongId,
    required TResult Function(String? message) unexpectedFailure,
  }) {
    return wrongId();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameTooLong,
    TResult Function()? notNumber,
    TResult Function()? wrongId,
    TResult Function(String? message)? unexpectedFailure,
    required TResult orElse(),
  }) {
    if (wrongId != null) {
      return wrongId();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NameTooLong value) nameTooLong,
    required TResult Function(NotNumber value) notNumber,
    required TResult Function(WrongId value) wrongId,
    required TResult Function(UnexpectedFailure value) unexpectedFailure,
  }) {
    return wrongId(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NameTooLong value)? nameTooLong,
    TResult Function(NotNumber value)? notNumber,
    TResult Function(WrongId value)? wrongId,
    TResult Function(UnexpectedFailure value)? unexpectedFailure,
    required TResult orElse(),
  }) {
    if (wrongId != null) {
      return wrongId(this);
    }
    return orElse();
  }
}

abstract class WrongId implements BirdFailure {
  const factory WrongId() = _$WrongId;
}

/// @nodoc
abstract class $UnexpectedFailureCopyWith<$Res> {
  factory $UnexpectedFailureCopyWith(
          UnexpectedFailure value, $Res Function(UnexpectedFailure) then) =
      _$UnexpectedFailureCopyWithImpl<$Res>;
  $Res call({String? message});
}

/// @nodoc
class _$UnexpectedFailureCopyWithImpl<$Res>
    extends _$BirdFailureCopyWithImpl<$Res>
    implements $UnexpectedFailureCopyWith<$Res> {
  _$UnexpectedFailureCopyWithImpl(
      UnexpectedFailure _value, $Res Function(UnexpectedFailure) _then)
      : super(_value, (v) => _then(v as UnexpectedFailure));

  @override
  UnexpectedFailure get _value => super._value as UnexpectedFailure;

  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(UnexpectedFailure(
      message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$UnexpectedFailure
    with DiagnosticableTreeMixin
    implements UnexpectedFailure {
  const _$UnexpectedFailure(this.message);

  @override
  final String? message;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BirdFailure.unexpectedFailure(message: $message)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BirdFailure.unexpectedFailure'))
      ..add(DiagnosticsProperty('message', message));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UnexpectedFailure &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  $UnexpectedFailureCopyWith<UnexpectedFailure> get copyWith =>
      _$UnexpectedFailureCopyWithImpl<UnexpectedFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() nameTooLong,
    required TResult Function() notNumber,
    required TResult Function() wrongId,
    required TResult Function(String? message) unexpectedFailure,
  }) {
    return unexpectedFailure(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nameTooLong,
    TResult Function()? notNumber,
    TResult Function()? wrongId,
    TResult Function(String? message)? unexpectedFailure,
    required TResult orElse(),
  }) {
    if (unexpectedFailure != null) {
      return unexpectedFailure(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NameTooLong value) nameTooLong,
    required TResult Function(NotNumber value) notNumber,
    required TResult Function(WrongId value) wrongId,
    required TResult Function(UnexpectedFailure value) unexpectedFailure,
  }) {
    return unexpectedFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NameTooLong value)? nameTooLong,
    TResult Function(NotNumber value)? notNumber,
    TResult Function(WrongId value)? wrongId,
    TResult Function(UnexpectedFailure value)? unexpectedFailure,
    required TResult orElse(),
  }) {
    if (unexpectedFailure != null) {
      return unexpectedFailure(this);
    }
    return orElse();
  }
}

abstract class UnexpectedFailure implements BirdFailure {
  const factory UnexpectedFailure(String? message) = _$UnexpectedFailure;

  String? get message => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UnexpectedFailureCopyWith<UnexpectedFailure> get copyWith =>
      throw _privateConstructorUsedError;
}
